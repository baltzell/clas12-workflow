#!/usr/bin/env python3
from tkinter import *
from tkinter import ttk
import tkinter.scrolledtext as scrolledtext
import concurrent.futures
import subprocess
import functools
import datetime
import threading
import signal
import json
import time
import os

root = Tk()
status_message = StringVar()
status_message.set('Loading...')
executor = None

def create_tab(name,forget=None):
    if forget is not None:
        tab_control.forget(forget)
    tab = scrolledtext.ScrolledText(tab_control, undo=True)
    tab.pack(fill='both',expand=True)
    tab_control.add(tab, text=name)
    tab_control.pack(expand=1, fill='both')
    return tab

def run(cmd):
    return subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True, timeout=30)

def get_file_lines(path):
    with open(path) as f:
        for x in f.readlines():
            yield(x.strip())

def format_log_file(path):
    lines = []
    if os.path.isfile(path):
        lines = list(get_file_lines(path))
        lines.insert(0,'>'*30)
        lines.insert(0,'>>>>> '+path)
        lines.insert(0,'>'*30)
        lines.extend(['\n','\n'])
    return lines


class Wokflow():
    def __init__(self, name):
        self.name = name
        self.header = None
        self.details = None
        self.tabs = {}
        self.guivals = {}
        for k in ['jobs','complete','dispatched_running','dispatched_preparing','dispatched_pending','dispatched_reaping','dispatched_other','undispatched','update_ts','problems','problem_types']:
            self.guivals[k] = StringVar()
            self.guivals[k].set('-')
        self.header_cmd = ['swif2','status','-display','json','-workflow',self.name]
        self.details_cmd = ['swif2','status','-jobs','-display','json','-workflow',self.name]
        self.known_problem_types = set()
    def reset(self):
        self.header = None
        self.details = None
        for v in self.guivals.values():
            v.set('-')
        for v in self.tabs.values():
            tab_control.forget(v)
        self.tabs = {}
    def update(self):
        self.reset()
        self.initialize()
    def initialize(self):
        status_message.set('Running '+' '.join(self.header_cmd)+' ...')
        executor.submit(self._import_header).add_done_callback(self._update_header)
    def _import_header(self):
        self.header = json.loads(subprocess.check_output(self.header_cmd).decode('UTF-8')).pop()
        status_message.set('Idle')
    def _import_details(self):
        self.details = json.loads(subprocess.check_output(self.details_cmd).decode('utf-8')).get('jobs')
        status_message.set('Idle')
    def _update_header(self, parent_task=None):
        for k,v in self.guivals.items():
            v.set(str(self.header.get(k)))
        self.guivals['update_ts'].set(datetime.datetime.utcfromtimestamp(int(self.header['update_ts'])/1000).strftime('%m/%d %H:%M:%S'))
        self.guivals['problem_types'].set('\n'.join(str(self.header.get('problem_types')).split(',')))
        complete = self.header.get('succeeded') / self.header.get('jobs')
        self.guivals['complete'].set('%.2f%%'%(complete*100))
        self._regenerate_menu()
    def _delete_menu_entry(self, label):
        try:
            self.menu_button.menu.delete(self.menu_button.menu.index(label))
        except TclError:
            pass
    def generate_menu(column, row):
        button = ttk.Menubutton(tab_summary, text='Options')
        button.grid(column=column, row=row, padx=3, pady=1)
        button.menu = Menu(button, tearoff=False)
        button['menu'] = button.menu
        return button
    def add_menu(self, column, row):
        self.menu_column = column
        self.menu_row = row
        self.menu_button = Wokflow.generate_menu(column, row)
        self.menu_button.menu.add_command(label='Full Details', command=self.show_full_details)
    def _regenerate_menu(self, parent_task=None):
        for x in ['Problem Details','Problem Logs']:
            self._delete_menu_entry(x)
        for x in self.known_problem_types:
            self._delete_menu_entry('Retry '+x)
        problems = self.header.get('problem_types')
        if problems is not None and problems != 'None':
            self.menu_button.menu.add_command(label='Problem Details', command=self.show_problem_details)
            self.menu_button.menu.add_command(label='Problem Logs', command=self.show_problem_logs)
            for x in problems.split(','):
                self.known_problem_types.add(x)
                if len(x) > 0 and x != 'None':
                    self.menu_button.menu.add_command(label='Retry '+x, command=functools.partial(self.retry,x))
    def _show_full_details(self, parent_task=None):
        self.tabs['full'] = create_tab(name='Full: '+self.name, forget=self.tabs.get('full'))
        self.tabs['full'].insert(1.0,json.dumps(self.details,indent=2,separators=(',',': ')))
    def _show_problem_details(self, parent_task=None):
        self.tabs['problems'] = create_tab(name='Problems: '+self.name, forget=self.tabs.get('problems'))
        self.tabs['problems'].insert(1.0,json.dumps(list(self._get_problem_jobs()),indent=2,separators=(',',': ')))
    def _show_problem_logs(self, parent_task=None):
        self.tabs['logs'] = create_tab(name='Logs: '+self.name, forget=self.tabs.get('logs'))
        lines = []
        for job in self._get_problem_jobs():
            for x in ['site_job_stderr','site_job_stdout']:
                if job.get(x) is not None:
                    lines.extend(format_log_file(job.get(x)))
        self.tabs['logs'].insert(1.0, '\n'.join(lines))
    def _get_problem_jobs(self, parent_task=None):
        for job in self.details:
            if job.get('job_attempt_status') == 'problem':
                yield job
    def show_full_details(self):
        if self.details is None:
            status_message.set('Running '+' '.join(self.details_cmd)+' ...')
            executor.submit(self._import_details).add_done_callback(self._show_full_details)
        else:
            self._show_full_details()
    def show_problem_details(self):
        if self.details is None:
            status_message.set('Running '+' '.join(self.details_cmd)+' ...')
            executor.submit(self._import_details).add_done_callback(self._show_problem_details)
        else:
            self._show_problem_details()
    def show_problem_logs(self):
        if self.details is None:
            status_message.set('Running '+' '.join(self.details_cmd)+' ...')
            executor.submit(self._import_details).add_done_callback(self._show_problem_logs)
        else:
            self._show_problem_logs()
    def retry(self, problem):
        cmd = ['swif2','retry-jobs','-workflow',self.name,'-problems',problem]
        executor.submit(run, cmd).add_done_callback(self.update)


workflows = {}
for w in json.loads(subprocess.check_output(['swif2','list','-display','json']).decode('UTF-8')):
    workflows[w['workflow_name']] = Wokflow(w['workflow_name'])

def handler(event):
    root.destroy()

def check():
    root.after(500, check)

height = 350
if len(workflows.keys()) > 4:
    height = min(800, len(workflows.keys())*int(270/7)+60)
root.geometry('%dx%d'%(1030,height))
root.title('SWIF GUI')
signal.signal(signal.SIGINT, lambda x,y : print('terminal ^C') or handler(None))
root.bind_all('<Control-c>',handler)
root.bind('<Return>', check)
root.after(500, check)
root.columnconfigure(0, weight=1)
root.rowconfigure(0, weight=1)
main_frame = ttk.Frame(root, padding='10 10 20 20')
main_frame.grid(column=0, row=0, sticky=(N,W,E,S))
tab_control = ttk.Notebook(root)
tab_summary = ttk.Frame(tab_control)
tab_control.add(tab_summary, text='Summary')
tab_control.pack(expand=1, fill='both')

row = 0
column = 0

def add_header(label):
    global column,row
    ttk.Label(tab_summary, text=label).grid(column=column, row=row, padx=5, pady=5)
    column += 1

def add_label(parent, textvar=None, text=None):
    global column,row
    if textvar is not None:
        ttk.Label(parent, textvariable=textvar).grid(column=column, row=row, padx=0, pady=0)
    elif text is not None:
        ttk.Label(parent, text=text).grid(column=column, row=row, padx=0, pady=0)
    column += 1

add_header('Name')
add_header('Complete')
add_header('Jobs')
add_header('Running')
add_header('Undispatched')
add_header('Preparing')
add_header('Pending')
add_header('Reaping')
add_header('Other')
add_header('Problems')
add_header('Problem Types')
add_header('Update')

row += 1
for name,w in workflows.items():
    column = 0
    add_label(tab_summary, text=name)
    add_label(tab_summary, textvar=w.guivals['complete'])
    add_label(tab_summary, textvar=w.guivals['jobs'])
    add_label(tab_summary, textvar=w.guivals['dispatched_running'])
    add_label(tab_summary, textvar=w.guivals['undispatched'])
    add_label(tab_summary, textvar=w.guivals['dispatched_preparing'])
    add_label(tab_summary, textvar=w.guivals['dispatched_pending'])
    add_label(tab_summary, textvar=w.guivals['dispatched_reaping'])
    add_label(tab_summary, textvar=w.guivals['dispatched_other'])
    add_label(tab_summary, textvar=w.guivals['problems'])
    add_label(tab_summary, textvar=w.guivals['problem_types'])
    add_label(tab_summary, textvar=w.guivals['update_ts'])
    w.add_menu(column, row)
    row += 1

def update():
    for w in workflows.values():
        w.update()

def initialize(delay=0):
    time.sleep(delay)
    for w in workflows.values():
        w.initialize()

ttk.Label(tab_summary, textvariable=status_message).grid(column=0, row=row, padx=0, pady=0, columnspan=column)
ttk.Button(tab_summary, text='Reload', command=update).grid(column=column, row=row, padx=0, pady=0)

with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
    executor.submit(initialize,5)
    root.mainloop()

