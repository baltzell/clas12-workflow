#!/usr/bin/env python3
from tkinter import *
from tkinter import ttk
import tkinter.scrolledtext as scrolledtext
import concurrent.futures
import subprocess
import functools
import datetime
import threading
import signal
import json
import time
import os

root = Tk()

class Wokflow():

    def __init__(self, name):
        self.name = name
        self.header = None
        self.details = None
        self.tabs = {}
        self.guivals = {}
        for k in ['jobs','complete','dispatched_running','dispatched_preparing','dispatched_pending','dispatched_reaping','dispatched_other','undispatched','update_ts','problems','problem_types']:
            self.guivals[k] = StringVar()
            self.guivals[k].set('-')
        self.header_cmd = ['swif2','status','-display','json','-workflow',self.name]
        self.details_cmd = ['swif2','status','-jobs','-display','json','-workflow',self.name]
        self.known_problem_types = set()

    def _reset(self):
        self.header = None
        self.details = None
        for v in self.guivals.values():
            v.set('-')
        self.delete_tabs()

    def delete_tabs(self):
        for v in self.tabs.values():
            tab_control.forget(v)
        self.tabs = {}

    def reload(self, parent_task=None):
        self.menu_button['state'] = 'disabled'
        self._reset()
        self.load()

    def load(self, parent_task=None):
        self.menu_button['state'] = 'disabled'
        status_message.set('Running '+' '.join(self.header_cmd)+' ...')
        executor.submit(self._import_header).add_done_callback(self._update_header)

    def retry(self, problem):
        self.menu_button['state'] = 'disabled'
        cmd = ['swif2','retry-jobs','-workflow',self.name,'-problems',problem]
        executor.submit(run_command, cmd).add_done_callback(self.load)

    def show_full_details(self):
        self.menu_button['state'] = 'disabled'
        if self.details is None:
            status_message.set('Running '+' '.join(self.details_cmd)+' ...')
            executor.submit(self._import_details).add_done_callback(self._show_full_details)
        else:
            self._show_full_details()

    def show_problem_details(self):
        self.menu_button['state'] = 'disabled'
        if self.details is None:
            status_message.set('Running '+' '.join(self.details_cmd)+' ...')
            executor.submit(self._import_details).add_done_callback(self._show_problem_details)
        else:
            self._show_problem_details()

    def show_problem_logs(self):
        self.menu_button['state'] = 'disabled'
        if self.details is None:
            status_message.set('Running '+' '.join(self.details_cmd)+' ...')
            executor.submit(self._import_details).add_done_callback(self._show_problem_logs)
        else:
            self._show_problem_logs()

    def add_menu_button(self, column, row):
        self.menu_column = column
        self.menu_row = row
        self.menu_button = create_menu(column, row)
        self.menu_button.menu.add_command(label='Full Details', command=self.show_full_details)

    def _import_header(self):
        self.header = json.loads(subprocess.check_output(self.header_cmd).decode('UTF-8')).pop()
        status_message.set('Idle')

    def _import_details(self):
        self.details = json.loads(subprocess.check_output(self.details_cmd).decode('utf-8')).get('jobs')
        status_message.set('Idle')

    def _delete_menu_entry(self, label):
        try:
            self.menu_button.menu.delete(self.menu_button.menu.index(label))
        except TclError:
            pass

    def _regenerate_menu(self, parent_task=None):
        for x in ['Problem Details','Problem Logs']:
            self._delete_menu_entry(x)
        for x in self.known_problem_types:
            self._delete_menu_entry('Retry '+x)
        problems = self.header.get('problem_types')
        if problems is not None and problems != 'None':
            self.menu_button.menu.add_command(label='Problem Details', command=self.show_problem_details)
            self.menu_button.menu.add_command(label='Problem Logs', command=self.show_problem_logs)
            for x in problems.split(','):
                self.known_problem_types.add(x)
                if len(x) > 0 and x != 'None':
                    self.menu_button.menu.add_command(label='Retry '+x, command=functools.partial(self.retry,x))

    def _update_header(self, parent_task=None):
        for k,v in self.guivals.items():
            v.set(str(self.header.get(k)))
        self.guivals['update_ts'].set(datetime.datetime.utcfromtimestamp(int(self.header['update_ts'])/1000).strftime('%m/%d %H:%M:%S'))
        self.guivals['problem_types'].set('\n'.join(str(self.header.get('problem_types')).split(',')))
        complete = self.header.get('succeeded') / self.header.get('jobs')
        self.guivals['complete'].set('%.2f%%'%(complete*100))
        self._regenerate_menu()
        self.menu_button['state'] = 'normal'

    def _show_full_details(self, parent_task=None):
        self.tabs['full'] = create_tab(name='Full: '+self.name, forget=self.tabs.get('full'))
        self.tabs['full'].insert(1.0,json.dumps(self.details,indent=2,separators=(',',': ')))
        self.menu_button['state'] = 'normal'

    def _show_problem_details(self, parent_task=None):
        self.tabs['problems'] = create_tab(name='Problems: '+self.name, forget=self.tabs.get('problems'))
        self.tabs['problems'].insert(1.0,json.dumps(list(self._get_problem_jobs()),indent=2,separators=(',',': ')))
        self.menu_button['state'] = 'normal'

    def _show_problem_logs(self, parent_task=None):
        self.tabs['logs'] = create_tab(name='Logs: '+self.name, forget=self.tabs.get('logs'))
        lines = []
        for job in self._get_problem_jobs():
            for x in ['site_job_stderr','site_job_stdout']:
                if job.get(x) is not None:
                    lines.extend(format_log_file(job.get(x)))
        self.tabs['logs'].insert(1.0, '\n'.join(lines))
        self.menu_button['state'] = 'normal'

    def _get_problem_jobs(self, parent_task=None):
        for job in self.details:
            if job.get('job_attempt_status') == 'problem':
                yield job

def load(delay=0):
    status_message.set('Loading ...')
    time.sleep(delay)
    for w in workflows.values():
        w.load()

def reload():
    status_message.set('Reloading ...')
    for w in workflows.values():
        w.reload()

def delete_tabs():
    for w in workflows.values():
        w.delete_tabs()

def create_tab(name, forget=None):
    if forget is not None:
        tab_control.forget(forget)
    tab = scrolledtext.ScrolledText(tab_control, undo=True)
    tab.pack(fill='both',expand=True)
    tab_control.add(tab, text=name)
    tab_control.grid(row=0, column=0)
    return tab

def create_menu(column, row, label='Options'):
    button = ttk.Menubutton(tab_summary, text=label)
    button.grid(column=column, row=row, padx=3, pady=1)
    button.menu = Menu(button, tearoff=False)
    button['menu'] = button.menu
    return button

def run_command(cmd):
    return subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True, timeout=30)

def get_file_lines(path):
    with open(path) as f:
        for x in f.readlines():
            yield(x.strip())

def format_log_file(path):
    lines = []
    if os.path.isfile(path):
        lines = list(get_file_lines(path))
        lines.insert(0,'>'*120)
        lines.insert(0,'>>>>> '+path)
        lines.insert(0,'>'*120)
        lines.extend(['\n','\n'])
    return lines

def add_header(label):
    global column,row
    ttk.Label(tab_summary, text=label).grid(column=column, row=row, padx=5, pady=5)
    column += 1

def add_label(parent, textvar=None, text=None):
    global column,row
    if textvar is not None:
        ttk.Label(parent, textvariable=textvar).grid(column=column, row=row, padx=0, pady=0)
    elif text is not None:
        ttk.Label(parent, text=text).grid(column=column, row=row, padx=0, pady=0)
    column += 1


def handler(event):
    root.destroy()
signal.signal(signal.SIGINT, lambda x,y : print('terminal ^C') or handler(None))

def check():
    root.after(500, check)

root.title('swif gui')
root.minsize(1070,350)
root.bind_all('<Control-c>',handler)
root.bind('<Return>', check)
root.after(500, check)
root.columnconfigure(0, weight=1)
root.rowconfigure(0, weight=1)
status_message = StringVar()
status_message.set('Loading...')
main_frame = ttk.Frame(root, padding='10 10 20 0')
main_frame.columnconfigure(0, weight=10)
main_frame.rowconfigure(0, weight=10)
main_frame.grid(column=0, row=0, sticky=(N,W,E,S))
tab_control = ttk.Notebook(main_frame)
tab_summary = ttk.Frame(tab_control)
tab_control.add(tab_summary, text='Summary')
tab_control.grid(column=0, row=0, sticky='nwes', columnspan=3)
status_bar = ttk.Label(main_frame, borderwidth=2, textvariable=status_message, anchor="w").grid(row=1, column=0, columnspan=10, padx=10, pady=2, sticky=(N,W,E,S))
ttk.Button(main_frame, text='Remove Tabs', command=delete_tabs).grid(row=1, column=1, pady=3)
ttk.Button(main_frame, text='Reload Workflows', command=reload).grid(row=1, column=2, pady=3)

row = 0
column = 0

add_header('Name')
add_header('Complete')
add_header('Jobs')
add_header('Running')
add_header('Undispatched')
add_header('Preparing')
add_header('Pending')
add_header('Reaping')
add_header('Other')
add_header('Problems')
add_header('Problem Types')
add_header('Update')

workflows = {}
print('Retrieving Workflows ....')
for w in json.loads(subprocess.check_output(['swif2','list','-archived','-display','json']).decode('UTF-8')):
    workflows[w['workflow_name']] = Wokflow(w['workflow_name'])

row += 1
for name,w in workflows.items():
    column = 0
    add_label(tab_summary, text=name)
    add_label(tab_summary, textvar=w.guivals['complete'])
    add_label(tab_summary, textvar=w.guivals['jobs'])
    add_label(tab_summary, textvar=w.guivals['dispatched_running'])
    add_label(tab_summary, textvar=w.guivals['undispatched'])
    add_label(tab_summary, textvar=w.guivals['dispatched_preparing'])
    add_label(tab_summary, textvar=w.guivals['dispatched_pending'])
    add_label(tab_summary, textvar=w.guivals['dispatched_reaping'])
    add_label(tab_summary, textvar=w.guivals['dispatched_other'])
    add_label(tab_summary, textvar=w.guivals['problems'])
    add_label(tab_summary, textvar=w.guivals['problem_types'])
    add_label(tab_summary, textvar=w.guivals['update_ts'])
    w.add_menu_button(column, row)
    row += 1

with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
    executor.submit(load,5)
    root.mainloop()

